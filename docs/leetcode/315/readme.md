# [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

## 题目描述

给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。

示例:

    输入: [5,2,6,1]
    输出: [2,1,1,0] 
    解释:
    5 的右侧有 2 个更小的元素 (2 和 1).
    2 的右侧仅有 1 个更小的元素 (1).
    6 的右侧有 1 个更小的元素 (1).
    1 的右侧有 0 个更小的元素.

## 解题思路

### 使用线段树

1. 求出nums的最小最大值，[min, max]作为线段树的根节点构造一棵树，节点维护区间内元素个数，构造的时候初始化为0
2. 从右向左遍历nums, 查询 [min, nums[i] - 1] 范围内个数，输出到结果
3. 线段树中 nums[i] 那个节点的 cnt 值+1, 递归更新相关节点的 cnt 值

该方法的缺点是当 max - min 非常大的时候占用空间大。使用该方法之前需要注意数据范围。

[[python](315.py)]

我们可以改进上面的方法是之更为通用， 不用在意最大值和最小值的差值，方法是预处理数组。
把数组的每个数字替换成排序之后的索引，这里要注意，如果数字相同，其排序之后的索引也要保持一样。

```
[5,2,6,1] --> [2,1,3,0]    [5,2,6,2,1] --> [3,1,4,1,0]
[2,1,1,0]     [2,1,1,0]    [3,1,2,1,0] --> [3,1,2,1,0]
```

可以看到， 转换之后的数组结果还是和之前一样的， 但是数据范围被缩放到[0,len(nums)-1].
这样预处理之后再使用上面线段树的方法，可以节省空间。

[python](315_2.py)

### 使用树状数组

把 nums 预处理成 nums[i] 的排名之后， 数组的值的范围就和下标一致。这样我们就可以不必维护 [begin, end] 范围，
而区间性质只需要一个数据便可以保存，所以可以使用树状数组做。

1. 预处理 nums 为其排名
2. 从右向做遍历 nums, 查询 [0, nums[i]-1] 区间内 cnt 值
3. nums[i] 加入树状数组，更新关联的节点的 cnt 值

[python](315_3.py)

### 使用归并排序思想

归并排序在合并两个有序的数组的时候， 后面的数组一定在前面数组所有元素的后面， 所以前面数组中的每个元素，
都可以快速找到后面数组有几个元素小于它。

我们使用 (num, index) 替换掉原来的 nums 数组， 对其进行归并排序， 每次 merge 的时候， 对于前面数组的每一个元素
计算后面数组中小于它的元素个数， 累加到 ans[index] 结果中。

归并排序完成之后， ans 中保存的就是最终的结果。
 
[python](315_4.py)