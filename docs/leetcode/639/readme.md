# [639. 解码方法 2](https://leetcode-cn.com/problems/decode-ways-ii/)

## 题目描述

一条包含字母 A-Z 的消息通过以下的方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*'了，字符'*'可以被当做1到9当中的任意一个数字。

给定一条包含数字和字符'*'的加密信息，请确定解码方法的总数。

同时，由于结果值可能会相当的大，所以你应当对109 + 7取模。（翻译者标注：此处取模主要是为了防止溢出）

示例 1 :

    输入: "*"
    输出: 9
    解释: 加密的信息可以被解密为: "A", "B", "C", "D", "E", "F", "G", "H", "I".

示例 2 :

    输入: "1*"
    输出: 9 + 9 = 18（翻译者标注：这里1*可以分解为1,* 或者当做1*来处理，所以结果是9+9=18）
    说明 :

    输入的字符串长度范围是 [1, 105]。
    输入的字符串只会包含字符 '*' 和 数字'0' - '9'。

## 解题思路

与 [91.解码方法]() 类似，都是使用动态规划从后向前解决。 需要注意的点：
1. `*` 取值的范围是1-9， 不包括0， `**`可以取值11-19， 21-26共15个元素
2. 解码方法数计算过程中需要用到 `9 * nextCount`, 这里可能会超出 `int` 的表示范围， 所以结果需要用 `long long` 类型保存。

```c
#define M 1000000007

/*
    "12*3", * 可以表示 1-9 任意数字
    设 dp[i] 表示 s[i...n] 的解码数量， dp[n] = 1
    if s[i] != '*', dp[i] = dp[i+1] + dp[i+2], 与 91 解码方法中对应的情况一样
    if s[i] == '*', dp[i] 可单独解析成 0-9 共9种情况， dp[i] = 9 * dp[i + 1]
                    dp[i], dp[i+1] 解析成字母的情况， if s[i+1] in [0,6], * 可以取 1， 2 共两种情况
                                                     if s[i+1] not in [0, 6], * 可以取 1 共一种情况
 */
int numDecodings(char * s){
    if (s == NULL) return 0;
    int n = strlen(s);
    long long nextNext = 1;
    long long next = (s[n-1] == '0') ? 0 : 1;
    long long curr;

    if (s[n-1] == '*') next = 9; // * 可以取 1-9 共 9 种情况
    for (int i = n - 2; i >= 0; i--) {
        if (s[i] == '*') {
            curr = 0;
            if (s[i + 1] >= '0' && s[i+1] <= '6') {
                curr = 2; // *[0-6], *可以取值 1， 2
            } else if (s[i+1] == '*') {
                curr = 15; // **, 可以取11-19， 21-26， 注意00-10， 20是不能取的
            } else {
                curr = 1; // *[7-9], *只能取 1， 因为 26 是最大值， 27是无法解码的
            }
            curr = curr * nextNext; // 对应两位数字解码一个字母的情况
            curr += 9 * next; // 对应 * 取1-9并且单独解码的情况
        } else if (s[i] == '0') {
            curr = 0; // 0 无法解码， 即使是0*也不能
        } else {
            curr = 0;
            if (s[i+1] == '*') {
                if (s[i] == '1') curr = 9; // 11-19 可以有9中解码方法
                if (s[i] == '2') curr = 6; // 21-26 可以有6种解码方法
            } else {
                int number = (s[i] - '0') * 10 + s[i+1] - '0';
                if (number >= 1 && number <= 26) {
                    curr = 1;
                }
            }
            curr = curr * nextNext;
            curr += next;
        }

        nextNext = next;
        next = curr % M;
    }

    return next;
}
```
