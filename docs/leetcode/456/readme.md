# [456. 132模式](https://leetcode-cn.com/problems/132-pattern)

## 题目描述

给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 ai, aj, ak 被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。

注意：n 的值小于15000。

示例1:

    输入: [1, 2, 3, 4]

    输出: False

    解释: 序列中不存在132模式的子序列。

示例 2:

    输入: [3, 1, 4, 2]

    输出: True

    解释: 序列中有 1 个132模式的子序列： [1, 4, 2].

示例 3:

    输入: [-1, 3, 2, 0]

    输出: True

    解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].


## 解题思路

ai最小， aj最大， 再从(j, end)之间找到一个在(ai, aj)之间的数字就可以。
对于任意的aj, 找到[0, j)区间的最小值，它是最佳的ai. 这个可以通过求前缀最小值实现，耗时O(n).
确定ai, aj之后，从(j, end)区间找一个小于aj的元素， 如果能够找到，说明有132模式。
使用一个栈维护(j, end)之间的元素，保持在栈中的元素降序，栈顶的元素最小。

算法描述：

1. 遍历一遍求mins, mins[i]表示[0, i]内最小的元素
2. for j in [n-1,0], if a[j] <= mins[j], j--; 如果从前面找不到比当前元素小的值，跳过
3. if a[j] > mins[j], 此时 ai = mins[j], aj = a[j], 
    如果栈非空， 弹出栈顶元素直到大于ai,
    如果栈非空， 栈顶元素小于aj, 则返回true
    否则，把a[j]压入栈中， j--, 继续下个循环

栈中维护的始终是j之后的元素，而且是大于ai的元素，一旦找到小于aj的就可以返回，如果遍历完还没有返回，说明没有满足条件的132模式。

## AC代码

- [C](456.c)
- [C++](456.cpp)
- [Python](456.py)
