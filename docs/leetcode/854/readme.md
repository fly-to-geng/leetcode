# [854. 相似度为 K 的字符串](https://leetcode-cn.com/problems/k-similar-strings/)

## 题目描述

如果可以通过将 A 中的两个小写字母精确地交换位置 K 次得到与 B 相等的字符串，我们称字符串 A 和 B 的相似度为 K（K 为非负整数）。

给定两个字母异位词 A 和 B ，返回 A 和 B 的相似度 K 的最小值。

 

示例 1：

    输入：A = "ab", B = "ba"
    输出：1

示例 2：

    输入：A = "abc", B = "bca"
    输出：2
    
示例 3：

    输入：A = "abac", B = "baca"
    输出：2

示例 4：

    输入：A = "aabc", B = "abca"
    输出：2
 

提示：

    1 <= A.length == B.length <= 20
    A 和 B 只包含集合 {'a', 'b', 'c', 'd', 'e', 'f'} 中的小写字母。

## 解题思路

### 方法一

广度优先搜索 + 剪枝

A B两个字符串逐个比较字符，遇到不相同的字母, 记录索引为 s, 向后寻找 A[j] == B[s] && A[j] != B[j] 的所有j,
全部加入队列， 结果+1， 继续。一旦搜索到B，就结束。

两点需要注意：

1. 记录已经搜索的节点，如果后续生成的字符串已经搜索过，说明已经有更短的答案，这个应该跳过
2. A[j] == B[j] 可以跳过是因为 替换之后也不会解决问题，依然还是两个字母不同，只不过把位置向后移动了，之后还要解决它。

[Python](854.py)

### 方法二

深度优先搜索 + 剪枝

思路同方法一，只不过使用深度优先搜索优先搜索到底，这样可能会多搜索，但是内存消耗少，只需要保存一次深搜的结果。

[Python](854_2.py)
